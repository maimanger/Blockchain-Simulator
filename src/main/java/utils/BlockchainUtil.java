package utils;

import com.google.common.hash.Hashing;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.Key;
import java.security.KeyFactory;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.Signature;
import java.security.SignatureException;
import java.security.spec.InvalidKeySpecException;
import java.security.spec.X509EncodedKeySpec;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.stream.Collectors;
import transaction.Transaction;


/**
 * This is a class contains static util methods in blockchain creation and operation.
 */
public class BlockchainUtil {

  /**
   * Convert a Key object to a hexadecimal string.
   *
   * @param key a given Key object
   * @return a converted hexadecimal string
   */
  public static String keyToString(Key key) {
    return Base64.getEncoder().encodeToString(key.getEncoded());
  }

  /**
   * Convert a hexadecimal string back to a PublicKey, generated by Elliptic-curve
   * cryptographic algorithm.
   *
   * @param keyStr a hexadecimal string represents a PublicKey
   * @return a converted PublicKey object
   */
  public static PublicKey stringToPublicKey(String keyStr) {
    PublicKey resultKey = null;
    byte[] byteKey = Base64.getDecoder().decode(keyStr);
    try {
      KeyFactory factory = KeyFactory.getInstance("ECDSA", "BC");
      resultKey = factory.generatePublic(new X509EncodedKeySpec(byteKey));
    } catch (NoSuchAlgorithmException | InvalidKeySpecException | NoSuchProviderException e) {
      e.printStackTrace();
    }
    return resultKey;
  }


/*  public static PrivateKey stringToPrivateKey(String keyStr) {
    PrivateKey resultKey = null;
    byte[] byteKey = Base64.getDecoder().decode(keyStr);
    try {
      KeyFactory factory = KeyFactory.getInstance("ECDSA", "BC");
      resultKey = factory.generatePrivate(new X509EncodedKeySpec(byteKey));
    } catch (NoSuchAlgorithmException | InvalidKeySpecException | NoSuchProviderException e) {
      e.printStackTrace();
    }
    return resultKey;
  }*/


  /**
   * Generate the hash code in the format of hexadecimal string by applying sha256 hashing function
   * to the given data string.
   *
   * @param data a given data string
   * @return a hexadecimal string generated by sha256 hashing function
   */
  public static String applySha256(String data) {
    return Hashing.sha256().hashString(data, StandardCharsets.UTF_8).toString();
  }

  /**
   * Generate a digital signature from a given data string combined with a specific PrivateKey,
   * by using Elliptic-curve cryptographic algorithm.
   *
   * @param privateKey a given PrivateKey object
   * @param data a given data string
   * @return a byte array represents the digital signature
   */
  public static byte[] encryptByECDSA(PrivateKey privateKey, String data) {
    byte[] signature = new byte[0];
    try {
      Signature digitalSig = Signature.getInstance("ECDSA", "BC");
      digitalSig.initSign(privateKey);
      digitalSig.update(data.getBytes());
      signature = digitalSig.sign();
    } catch (NoSuchAlgorithmException | SignatureException | NoSuchProviderException
            | InvalidKeyException e) {
      e.printStackTrace();
    }
    return signature;
  }

  /**
   * Verify a given digital signature by the given PublicKey and the data string, by using
   * Elliptic-curve cryptographic algorithm.
   *
   * @param publicKey a given PublicKey object
   * @param signature a given byte array represents the digital signature
   * @param data a given data string
   * @return a boolean value, which is true if the signature is valid
   */
  public static boolean verifyByECDSA(PublicKey publicKey, byte[] signature, String data) {
    try {
      Signature digitalSig = Signature.getInstance("ECDSA", "BC");
      digitalSig.initVerify(publicKey);
      digitalSig.update(data.getBytes());
      return digitalSig.verify(signature);
    } catch (NoSuchAlgorithmException | SignatureException | NoSuchProviderException
            | InvalidKeyException e) {
      e.printStackTrace();
    }
    return false;
  }

  /**
   * Calculate the root of a merkle tree based on the given list of transactions.
   *
   * @param transactions a given list of transactions
   * @return a string represents the hash code of the resulting merkle root
   */
  public static String calculateMerkleRoot(List<Transaction> transactions) {
    if (transactions.isEmpty()) {
      return "";
    } else {
      List<String> thisTreeLayer =
              transactions.stream().map(Transaction::getID).collect(Collectors.toList());
      List<String> nextTreeLayer;

      while (thisTreeLayer.size() > 1) {
        nextTreeLayer = new ArrayList<>();

        for (int i = 0; i < thisTreeLayer.size(); i += 2) {
          // if thisTreeLayer has odd elements and i is the last index,
          // calculate the hash in the next layer by using two i-th elements.
          // Otherwise calculate the hash in the next layer by using the i-th element
          // and the (i+1)-th element
          if (i == thisTreeLayer.size() - 1) {
            nextTreeLayer.add(BlockchainUtil.applySha256(thisTreeLayer.get(i)
                    + thisTreeLayer.get(i)));
          } else {
            nextTreeLayer.add(BlockchainUtil.applySha256(thisTreeLayer.get(i)
                    + thisTreeLayer.get(i + 1)));
          }
          thisTreeLayer = nextTreeLayer;
        }
      }
      return thisTreeLayer.get(0);
    }
  }

}
